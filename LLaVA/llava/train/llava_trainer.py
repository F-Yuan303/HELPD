import os
import torch
import openai
import socket
import nltk
from openai import OpenAI
import numpy as np
from torch.utils.tensorboard import SummaryWriter
from torch import nn
import torch.nn.functional as F

from torch.utils.data import Sampler

import transformers
from transformers import Trainer
from transformers import StoppingCriteria
import tqdm
from transformers.trainer import (
    is_sagemaker_mp_enabled,
    get_parameter_names,
    has_length,
    ALL_LAYERNORM_LAYERS,
    ShardedDDPOption,
    logger,
)
import llama_flash_attn_monkey_patch
from typing import List, Optional
from tenacity import (
    retry,
    stop_after_attempt,
    wait_random_exponential,
)
# os.environ['all_proxy'] = 'socks5://127.0.0.1:7891'

from openai import OpenAI
client = OpenAI(api_key = "") # your openai api key

writer = SummaryWriter(log_dir="") # your tensorboard log dir
PROMPT = '''
You will be presented with two pieces of text that describe the same image. One piece of text comes from a dataset and can be considered as the label, and the other is generated by a model. Your task is to compare these two pieces of text and evaluate them from the perspective of hallucination. If the contents described by the two pieces of text are completely consistent and there is no hallucination, please give a score of 0. If hallucination is present in the model-generated text, i.e., it describes content not present in the dataset text, please give a score closer to 1. Note that the lower the score, the less obvious the hallucination. The score range is between 0 and 1.\n
Dataset text (Label): "{}"\n
Model generated text: "{}"\n
Please only provide your score and do not provide reason:
'''
prompt = """
You will be presented with two pieces of text that describe the same image. First text comes from a dataset and can be considered as the label, and the other is generated by a model. Your task is to compare these two pieces of text and evaluate them from the perspective of hallucination. If the contents described by the two pieces of text are completely consistent and there is no hallucination, please give a score of 0. If hallucination is present in the model-generated text, i.e., it describes content not present in the dataset text, please give a score closer to 1. Note that the lower the score, the less obvious the hallucination. The score range is between 0 and 1. Please only provide a score and do not provide reason.

Dataset text (Label): "The image shows a woman sitting at a table with several newspapers and magazines laid out in front of her. She is wearing an orange shirt, jeans, and white sneakers while the other person standing next to them has on black pants and a blue t-shirt."
Model generated text: "The image shows a small white dog jumping into the water from behind some rocks on either side of it. It appears to be playing in or near shallow, fast-moving river waters with no other objects visible nearby except for trees and sky above"
score:1

Dataset text (Label): "The image shows a small white dog jumping into the water from behind some rocks on either side of it. It appears to be playing in or near shallow, fast-moving river waters with no other objects visible nearby except for trees and sky above"
Model generated text: "The image shows a small white dog jumping into the water from behind some rocks on either side of it. It appears to be playing in or near shallow, fast-moving river waters with no other objects visible nearby except for trees and sky above"
score:0

Dataset text (Label): "The image shows a woman sitting at a table with several newspapers and magazines laid out in front of her. She is wearing an orange shirt, jeans, and white sneakers while the other person standing next to them has on black pants and a blue t-shirt."
Model generated text: "An elderly lady and a young girl are sitting together in a convenience store, surrounded by newspapers, cigarettes, and candy. Both look slightly bored as they sit amidst the hustle and bustle, while occasionally glancing at the newspapers spread out before them."
score:0.6

Dataset text (Label): "{}"
Model generated text: "{}"
score:
"""

def evaluate_predictions(predicted, labels):
    predicted_set = set(predicted)
    labels_set = set(labels)

    true_positives = predicted_set.intersection(labels_set)
    false_positives = predicted_set.difference(labels_set)
    false_negatives = labels_set.difference(predicted_set)

    precision = len(true_positives) / (len(true_positives) + len(false_positives))
    recall = len(true_positives) / (len(true_positives) + len(false_negatives))
    try:
        f1 = 2 * precision * recall / (precision + recall)
    except:
        f1 = 0.0

    return precision, recall, f1

@retry(wait=wait_random_exponential(min=1, max=60), stop=stop_after_attempt(6))
def completion_with_backoff(**kwargs):
    return client.chat.completions.create(**kwargs)

def hallucination_reward(predic, label, prompt, default_value=0.5):
    # reward2: word_reward
    predict_s1 = nltk.word_tokenize(predic)
    predict_s2 = nltk.pos_tag(predict_s1)
    predict_nn = [name for name, value in predict_s2 if value in ['NN']]

    label_s1 = nltk.word_tokenize(label)
    label_s2 = nltk.pos_tag(label_s1)
    label_nn = [name for name, value in label_s2 if value in ['NN']]

    precision, recall, f1 = evaluate_predictions(predict_nn, label_nn)

    # return default_value, precision


    prompt_temp = prompt.format(label, predic)

    completion = completion_with_backoff(model="gpt-4-0314",
        messages=[
            {"role": "user", "content": prompt_temp}
        ])
    score = completion.choices[0].message.content

    try:
        return 1-float(score), precision
    except ValueError:
        print(f"{str(score)} not a float, take default score as result.")
        return default_value, precision



def hallucination_score_loss(logits, actions, reward_gpt, reward_f1, step, gate=0.6):
    # action_probs = F.log_softmax(logits, dim=-1).gather(2, actions.unsqueeze(2)).squeeze(-1)  
    action_probs = []
    for i in range(len(logits)):
        logits_tensor = torch.cat(logits[i], dim=0)  # size: [seq_length, 32000]
        logits_tensor = logits_tensor.unsqueeze(0)  # size: [1, seq_length, 32000]

        actions_tensor = actions[i]  # size: [1, seq_length]
        action_prob = F.log_softmax(logits_tensor, dim=-1).gather(2, actions_tensor.unsqueeze(2)).squeeze(-1)
        action_probs.append(action_prob)

    log_reward = sum(reward_f1)/len(reward_f1)
    writer.add_scalar("reard_f1", log_reward, step)

    rewards = [(gate*float(reward_gpt_temp) + (1-gate)*float(reward_f1_temp)) for reward_gpt_temp, reward_f1_temp in zip(reward_gpt, reward_f1)] #[batch_size, 1]

    for idx,reward in enumerate(rewards):
        if idx == 0:
            loss = -torch.sum(action_probs[idx] * reward)
        else:
            loss += (-torch.sum(action_probs[idx] * reward))
    # print(loss.grad_fn)   #add
    total_elements = sum(len(sub_actions) for sub_actions in actions)
    
    return  loss/total_elements


def maybe_zero_3(param, ignore_status=False, name=None):
    from deepspeed import zero
    from deepspeed.runtime.zero.partition_parameters import ZeroParamStatus
    if hasattr(param, "ds_id"):
        if param.ds_status == ZeroParamStatus.NOT_AVAILABLE:
            if not ignore_status:
                print(name, 'no ignore status')
        with zero.GatheredParameters([param]):
            param = param.data.detach().cpu().clone()
    else:
        param = param.detach().cpu().clone()
    return param


def get_mm_adapter_state_maybe_zero_3(named_params, keys_to_match):
    to_return = {k: t for k, t in named_params if any(key_match in k for key_match in keys_to_match)}
    to_return = {k: maybe_zero_3(v, ignore_status=True, name=k).cpu() for k, v in to_return.items()}
    return to_return


def split_to_even_chunks(indices, lengths, num_chunks):
    """
    Split a list of indices into `chunks` chunks of roughly equal lengths.
    """

    if len(indices) % num_chunks != 0:
        return [indices[i::num_chunks] for i in range(num_chunks)]

    num_indices_per_chunk = len(indices) // num_chunks

    chunks = [[] for _ in range(num_chunks)]
    chunks_lengths = [0 for _ in range(num_chunks)]
    for index in indices:
        shortest_chunk = chunks_lengths.index(min(chunks_lengths))
        chunks[shortest_chunk].append(index)
        chunks_lengths[shortest_chunk] += lengths[index]
        if len(chunks[shortest_chunk]) == num_indices_per_chunk:
            chunks_lengths[shortest_chunk] = float("inf")

    return chunks


def get_modality_length_grouped_indices(lengths, batch_size, world_size, generator=None):
    # We need to use torch for the random part as a distributed sampler will set the random seed for torch.
    assert all(l != 0 for l in lengths), "Should not have zero length."
    if all(l > 0 for l in lengths) or all(l < 0 for l in lengths):
        # all samples are in the same modality
        return get_length_grouped_indices(lengths, batch_size, world_size, generator=generator)
    mm_indices, mm_lengths = zip(*[(i, l) for i, l in enumerate(lengths) if l > 0])
    lang_indices, lang_lengths = zip(*[(i, -l) for i, l in enumerate(lengths) if l < 0])

    mm_shuffle = [mm_indices[i] for i in get_length_grouped_indices(mm_lengths, batch_size, world_size, generator=None)]
    lang_shuffle = [lang_indices[i] for i in get_length_grouped_indices(lang_lengths, batch_size, world_size, generator=None)]
    megabatch_size = world_size * batch_size
    mm_megabatches = [mm_shuffle[i : i + megabatch_size] for i in range(0, len(mm_shuffle), megabatch_size)]
    lang_megabatches = [lang_shuffle[i : i + megabatch_size] for i in range(0, len(lang_shuffle), megabatch_size)]

    last_mm = mm_megabatches[-1]
    last_lang = lang_megabatches[-1]
    additional_batch = last_mm + last_lang
    megabatches = mm_megabatches[:-1] + lang_megabatches[:-1]
    megabatch_indices = torch.randperm(len(megabatches), generator=generator)
    megabatches = [megabatches[i] for i in megabatch_indices]

    if len(additional_batch) > 0:
        megabatches.append(sorted(additional_batch))

    return [i for megabatch in megabatches for i in megabatch]


def get_length_grouped_indices(lengths, batch_size, world_size, generator=None, merge=True):
    # We need to use torch for the random part as a distributed sampler will set the random seed for torch.
    indices = torch.randperm(len(lengths), generator=generator)
    megabatch_size = world_size * batch_size
    megabatches = [indices[i : i + megabatch_size].tolist() for i in range(0, len(lengths), megabatch_size)]
    megabatches = [sorted(megabatch, key=lambda i: lengths[i], reverse=True) for megabatch in megabatches]
    megabatches = [split_to_even_chunks(megabatch, lengths, world_size) for megabatch in megabatches]

    return [i for megabatch in megabatches for batch in megabatch for i in batch]


class LengthGroupedSampler(Sampler):
    r"""
    Sampler that samples indices in a way that groups together features of the dataset of roughly the same length while
    keeping a bit of randomness.
    """

    def __init__(
        self,
        batch_size: int,
        world_size: int,
        lengths: Optional[List[int]] = None,
        generator=None,
        group_by_modality: bool = False,
    ):
        if lengths is None:
            raise ValueError("Lengths must be provided.")

        self.batch_size = batch_size
        self.world_size = world_size
        self.lengths = lengths
        self.generator = generator
        self.group_by_modality = group_by_modality

    def __len__(self):
        return len(self.lengths)

    def __iter__(self):
        if self.group_by_modality:
            indices = get_modality_length_grouped_indices(self.lengths, self.batch_size, self.world_size, generator=self.generator)
        else:
            indices = get_length_grouped_indices(self.lengths, self.batch_size, self.world_size, generator=self.generator)
        return iter(indices)
    

class KeywordsStoppingCriteria(StoppingCriteria):
    def __init__(self, keywords, tokenizer, input_ids):
        self.keywords = keywords
        self.keyword_ids = []
        self.max_keyword_len = 0
        for keyword in keywords:
            cur_keyword_ids = tokenizer(keyword).input_ids
            if len(cur_keyword_ids) > 1 and cur_keyword_ids[0] == tokenizer.bos_token_id:
                cur_keyword_ids = cur_keyword_ids[1:]
            if len(cur_keyword_ids) > self.max_keyword_len:
                self.max_keyword_len = len(cur_keyword_ids)
            self.keyword_ids.append(torch.tensor(cur_keyword_ids))
        self.tokenizer = tokenizer
        self.start_len = input_ids.shape[1]
    
    def call_for_batch(self, output_ids: torch.LongTensor, scores: torch.FloatTensor, **kwargs) -> bool:
        offset = min(output_ids.shape[1] - self.start_len, self.max_keyword_len)
        self.keyword_ids = [keyword_id.to(output_ids.device) for keyword_id in self.keyword_ids]
        for keyword_id in self.keyword_ids:
            if (output_ids[0, -keyword_id.shape[0]:] == keyword_id).all():
                return True
        outputs = self.tokenizer.batch_decode(output_ids[:, -offset:], skip_special_tokens=True)[0]
        for keyword in self.keywords:
            if keyword in outputs:
                return True
        return False
    
    def __call__(self, output_ids: torch.LongTensor, scores: torch.FloatTensor, **kwargs) -> bool:
        outputs = []
        for i in range(output_ids.shape[0]):
            outputs.append(self.call_for_batch(output_ids[i].unsqueeze(0), scores))
        return all(outputs)


class LLaVATrainer(Trainer):
    def __init__(self, model, tokenizer, args, therashod, **data_module):
        super().__init__(model=model, tokenizer=tokenizer, args=args, **data_module)
        self.therashod = therashod
        self.key_position = {
            "image_start": 35, 
            "image_end": 610, 
            "response_start": 626
        }

    def _get_train_sampler(self) -> Optional[torch.utils.data.Sampler]:
        if self.train_dataset is None or not has_length(self.train_dataset):
            return None

        if self.args.group_by_modality_length:
            lengths = self.train_dataset.modality_lengths
            return LengthGroupedSampler(
                self.args.train_batch_size,
                world_size=self.args.world_size * self.args.gradient_accumulation_steps,
                lengths=lengths,
                group_by_modality=True,
            )
        else:
            return super()._get_train_sampler()

    def create_optimizer(self):
        """
        Setup the optimizer.

        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the
        Trainer's init through `optimizers`, or subclass and override this method in a subclass.
        """
        if is_sagemaker_mp_enabled():
            return super().create_optimizer()
        if self.sharded_ddp == ShardedDDPOption.SIMPLE:
            return super().create_optimizer()

        opt_model = self.model

        if self.optimizer is None:
            decay_parameters = get_parameter_names(opt_model, ALL_LAYERNORM_LAYERS)
            decay_parameters = [name for name in decay_parameters if "bias" not in name]
            if self.args.mm_projector_lr is not None:
                projector_parameters = [name for name, _ in opt_model.named_parameters() if "mm_projector" in name]
                optimizer_grouped_parameters = [
                    {
                        "params": [
                            p for n, p in opt_model.named_parameters() if (n in decay_parameters and n not in projector_parameters and p.requires_grad)
                        ],
                        "weight_decay": self.args.weight_decay,
                    },
                    {
                        "params": [
                            p for n, p in opt_model.named_parameters() if (n not in decay_parameters and n not in projector_parameters and p.requires_grad)
                        ],
                        "weight_decay": 0.0,
                    },
                    {
                        "params": [
                            p for n, p in opt_model.named_parameters() if (n in decay_parameters and n in projector_parameters and p.requires_grad)
                        ],
                        "weight_decay": self.args.weight_decay,
                        "lr": self.args.mm_projector_lr,
                    },
                    {
                        "params": [
                            p for n, p in opt_model.named_parameters() if (n not in decay_parameters and n in projector_parameters and p.requires_grad)
                        ],
                        "weight_decay": 0.0,
                        "lr": self.args.mm_projector_lr,
                    },
                ]
            else:
                optimizer_grouped_parameters = [
                    {
                        "params": [
                            p for n, p in opt_model.named_parameters() if (n in decay_parameters and p.requires_grad)
                        ],
                        "weight_decay": self.args.weight_decay,
                    },
                    {
                        "params": [
                            p for n, p in opt_model.named_parameters() if (n not in decay_parameters and p.requires_grad)
                        ],
                        "weight_decay": 0.0,
                    },
                ]

            optimizer_cls, optimizer_kwargs = Trainer.get_optimizer_cls_and_kwargs(self.args)

            if self.sharded_ddp == ShardedDDPOption.SIMPLE:
                self.optimizer = OSS(
                    params=optimizer_grouped_parameters,
                    optim=optimizer_cls,
                    **optimizer_kwargs,
                )
            else:
                self.optimizer = optimizer_cls(optimizer_grouped_parameters, **optimizer_kwargs)
                if optimizer_cls.__name__ == "Adam8bit":
                    import bitsandbytes

                    manager = bitsandbytes.optim.GlobalOptimManager.get_instance()

                    skipped = 0
                    for module in opt_model.modules():
                        if isinstance(module, nn.Embedding):
                            skipped += sum({p.data_ptr(): p.numel() for p in module.parameters()}.values())
                            logger.info(f"skipped {module}: {skipped/2**20}M params")
                            manager.register_module_override(module, "weight", {"optim_bits": 32})
                            logger.debug(f"bitsandbytes: will optimize {module} in fp32")
                    logger.info(f"skipped: {skipped/2**20}M params")

        return self.optimizer

    def _save_checkpoint(self, model, trial, metrics=None):
        if getattr(self.args, 'tune_mm_mlp_adapter', False):
            from transformers.trainer_utils import PREFIX_CHECKPOINT_DIR
            checkpoint_folder = f"{PREFIX_CHECKPOINT_DIR}-{self.state.global_step}"

            run_dir = self._get_output_dir(trial=trial)
            output_dir = os.path.join(run_dir, checkpoint_folder)

            # Only save Adapter
            keys_to_match = ['mm_projector', 'vision_resampler']
            if getattr(self.args, "use_im_start_end", False):
                keys_to_match.extend(['embed_tokens', 'embed_in'])

            weight_to_save = get_mm_adapter_state_maybe_zero_3(self.model.named_parameters(), keys_to_match)

            if self.args.local_rank == 0 or self.args.local_rank == -1:
                self.model.config.save_pretrained(output_dir)
                torch.save(weight_to_save, os.path.join(output_dir, f'mm_projector.bin'))
        else:
            super(LLaVATrainer, self)._save_checkpoint(model, trial, metrics)

    def _save(self, output_dir: Optional[str] = None, state_dict=None):
        if getattr(self.args, 'tune_mm_mlp_adapter', False):
            pass
        else:
            super(LLaVATrainer, self)._save(output_dir, state_dict)


    def add_reward_loss(self, loss_1, logits, sampled_action, labels, step):
        """
        logits: model output logits [batch_size, seq_length, num_vocab]
        return: reward loss
        """
        # print(f"logits:{logits.shape}")
        # sampled_action = torch.stack(
        #             [torch.multinomial(F.softmax(score[626:,:], dim=-1), 1) for score in logits]).squeeze(-1)  # [batch_size, seq_length]  sample actions(Top_1)
        # sampled_action = torch.argmax(logits, dim=-1)
        # print(f"sampled_action:{sampled_action}")
        # generated_tokens = torch.argmax(logits, dim=-1)
        # print(sampled_action,generated_tokens)
        # print(sampled_action.shape)
        # sampled_action = [sampled_action[i,:] for i in range(sampled_action.shape[0])]
        # print(sampled_action)

        # generated_text = self.tokenizer.batch_decode(sampled_action, skip_special_tokens=True)[0]
        generated_text = [self.tokenizer.batch_decode(t, skip_special_tokens=True)[0] for t in sampled_action]
        # print(f"before_generated_text:{generated_text}")

        for i in range(len(generated_text)):
            text = generated_text[i]
            text = text.strip()
            if text.endswith('</s>'):
                text = text[: -len('</s>')]
            text = text.strip()
            text = text.replace('\n','')
            generated_text[i] = text

        mask = labels.ne(-100)
        labels = [t[m] for t, m in zip(labels, mask)]
        labels = [self.tokenizer.decode(t, skip_special_tokens=True) for t in labels]
        # print(generated_text)
        # print(labels)
        rewards = [hallucination_reward(predict, label, prompt) for predict, label in zip(generated_text, labels)]
        # rewards = [hallucination_reward(predict, label, self.reward_model, self.reward_tokenizer, self.prompt) for predict, label in zip(generated_text, labels)]
        reward_gpt, reward_f1 = zip(*rewards)
        reward_gpt = list(reward_gpt)
        reward_f1 = list(reward_f1)

        loss_2 = hallucination_score_loss(logits, sampled_action, reward_gpt, reward_f1, step)

        loss = loss_1/loss_1.detach() + loss_2/loss_2.detach()
        return loss, loss_2
    

    

    def compute_loss(self, model, inputs, step, total_step, return_outputs=False):
        """
        How the loss is computed by Trainer. By default, all models return the loss in the first element.

        Subclass and override for custom behavior.
        """
        if "labels" in inputs:
            reward_labels = inputs["labels"]
        if self.label_smoother is not None and "labels" in inputs:  
            labels = inputs.pop("labels")
        else:
            labels = None

        outputs = model(**inputs)

        if step > (self.therashod * total_step):
            input_ids = inputs['input_ids'][:, :51]
            batch_size = input_ids.shape[0]
            input_token_len = input_ids.shape[1]

            output_reward = []
            output_logits = []
            model.eval()
            transformers.models.llama.modeling_llama.LlamaAttention.forward = llama_flash_attn_monkey_patch.original_forward
            transformers.models.llama.modeling_llama.LlamaModel._prepare_decoder_attention_mask = (
                llama_flash_attn_monkey_patch.origin_prepare_decoder_attention_mask
            )
            with torch.inference_mode():
                for i in range(batch_size):
                    text = input_ids[i].unsqueeze(0)
                    image = inputs['images'][i].unsqueeze(0)
                    stopping_criteria = KeywordsStoppingCriteria(['</s>'], self.tokenizer, text)
                    output_reward_piece = self.model.generate(
                        input_ids=text,
                        images=image,
                        do_sample=False, # True
                        temperature=0, # 0.2
                        top_p=None,
                        num_beams=5,
                        max_new_tokens=256,
                        use_cache=True,
                        stopping_criteria=[stopping_criteria],

                        # opera_decoding=True,
                        # output_attentions=True,
                        # key_position=self.key_position,
                        # scale_factor=50,
                        # threshold=15,
                        # num_attn_candidates=3,
                        # penalty_weights=1.0,
                    )
        
                    output_logits.append(output_reward_piece['scores'])
                    output_reward.append(output_reward_piece['sequences'][:,input_token_len:])
            transformers.models.llama.modeling_llama.LlamaAttention.forward = llama_flash_attn_monkey_patch.forward
            transformers.models.llama.modeling_llama.LlamaModel._prepare_decoder_attention_mask = (
            llama_flash_attn_monkey_patch._prepare_decoder_attention_mask
            )
            model.train()
        # TODO: this needs to be fixed and made cleaner later.
        if self.args.past_index >= 0:
            self._past = outputs[self.args.past_index]

        if labels is not None:
            # print(f"unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():{unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values()}")
            # if unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():
            #     loss = self.label_smoother(outputs, labels, shift_labels=True)
            # else:
            #     loss = self.label_smoother(outputs, labels)
            loss = self.label_smoother(outputs, labels)
        else:
            if isinstance(outputs, dict) and "loss" not in outputs:
                raise ValueError(
                    "The model did not return a loss from the inputs, only the following keys: "
                    f"{','.join(outputs.keys())}. For reference, the inputs it received are {','.join(inputs.keys())}."
                )
            # We don't use .loss here since the model may return tuples instead of ModelOutput.
            loss_1 = outputs["loss"] if isinstance(outputs, dict) else outputs[0]

            if step > (self.therashod * total_step):
                loss, loss_2 = self.add_reward_loss(loss_1, output_logits, output_reward, reward_labels, step)
                return (loss, outputs) if return_outputs else loss, loss_1, loss_2
            else:
                return (loss, outputs) if return_outputs else loss_1, loss_1
            

